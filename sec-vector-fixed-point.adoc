
[[sec-vector-fixed-point]]
== Vector Fixed-Point Arithmetic Instructions

The preceding set of integer arithmetic instructions is extended to support
fixed-point arithmetic.

A fixed-point number is a two's-complement signed or unsigned integer 
interpreted as the numerator in a fraction with an implicit denominator.
The fixed-point instructions are intended to be applied to the numerators; 
it is the responsibility of software to manage the denominators. 
An N-bit element can hold two's-complement signed integers in the
range -2^N-1^...+2^N-1^-1, and unsigned integers in the range 0
... +2^N^-1.  The fixed-point instructions help preserve precision in
narrow operands by supporting scaling and rounding, and can handle
overflow by saturating results into the destination format range.

NOTE: The widening integer operations described above can also be used
to avoid overflow.

=== Vector Single-Width Saturating Add and Subtract

Saturating forms of integer add and subtract are provided, for both
signed and unsigned integers.  If the result would overflow the
destination, the result is replaced with the closest representable
value, and the `vxsat` bit is set.

----
# Saturating adds of unsigned integers.
vsaddu.vv vd, vs2, vs1, vm   # Vector-vector
vsaddu.vx vd, vs2, rs1, vm   # vector-scalar
vsaddu.vi vd, vs2, imm, vm   # vector-immediate

# Saturating adds of signed integers.
vsadd.vv vd, vs2, vs1, vm   # Vector-vector
vsadd.vx vd, vs2, rs1, vm   # vector-scalar
vsadd.vi vd, vs2, imm, vm   # vector-immediate

# Saturating subtract of unsigned integers.
vssubu.vv vd, vs2, vs1, vm   # Vector-vector
vssubu.vx vd, vs2, rs1, vm   # vector-scalar

# Saturating subtract of signed integers.
vssub.vv vd, vs2, vs1, vm   # Vector-vector
vssub.vx vd, vs2, rs1, vm   # vector-scalar
----

=== Vector Single-Width Averaging Add and Subtract

The averaging add and subtract instructions right shift the result by
one bit and round off the result according to the setting in `vxrm`.
Both unsigned and signed versions are provided.
For `vaaddu` and `vaadd` there can be no overflow in the result.
For `vasub` and `vasubu`, overflow is ignored and the result wraps around.

NOTE: For `vasub`, overflow occurs only when subtracting the smallest number
from the largest number under `rnu` or `rne` rounding.

----
# Averaging add

# Averaging adds of unsigned integers.
vaaddu.vv vd, vs2, vs1, vm   # roundoff_unsigned(vs2[i] + vs1[i], 1)
vaaddu.vx vd, vs2, rs1, vm   # roundoff_unsigned(vs2[i] + x[rs1], 1)

# Averaging adds of signed integers.
vaadd.vv vd, vs2, vs1, vm   # roundoff_signed(vs2[i] + vs1[i], 1)
vaadd.vx vd, vs2, rs1, vm   # roundoff_signed(vs2[i] + x[rs1], 1)

# Averaging subtract

# Averaging subtract of unsigned integers.
vasubu.vv vd, vs2, vs1, vm   # roundoff_unsigned(vs2[i] - vs1[i], 1)
vasubu.vx vd, vs2, rs1, vm   # roundoff_unsigned(vs2[i] - x[rs1], 1)

# Averaging subtract of signed integers.
vasub.vv vd, vs2, vs1, vm   # roundoff_signed(vs2[i] - vs1[i], 1)
vasub.vx vd, vs2, rs1, vm   # roundoff_signed(vs2[i] - x[rs1], 1)
----

=== Vector Single-Width Fractional Multiply with Rounding and Saturation

The signed fractional multiply instruction produces a 2*SEW product of
the two SEW inputs, then shifts the result right by SEW-1 bits,
rounding these bits according to `vxrm`, then saturates the result to
fit into SEW bits.  If the result causes saturation, the `vxsat` bit
is set.

----
# Signed saturating and rounding fractional multiply
# See vxrm  description for rounding calculation
vsmul.vv vd, vs2, vs1, vm  # vd[i] = clip(roundoff_signed(vs2[i]*vs1[i], SEW-1))
vsmul.vx vd, vs2, rs1, vm  # vd[i] = clip(roundoff_signed(vs2[i]*x[rs1], SEW-1))
----

[NOTE]
====
When multiplying two N-bit signed numbers, the largest magnitude
is obtained for -2^N-1^ * -2^N-1^ producing a result +2^2N-2^, which
has a single (zero) sign bit when held in 2N bits.  All other products
have two sign bits in 2N bits.  To retain greater precision in N
result bits, the product is shifted right by one bit less than N,
saturating the largest magnitude result but increasing result
precision by one bit for all other products.

We do not provide an equivalent fractional multiply where one
input is unsigned, as these would retain all upper SEW bits and would
not need to saturate.  This operation is partly covered by the
`vmulhu` and `vmulhsu` instructions, for the case where rounding is
simply truncation (`rdn`).
====

=== Vector Single-Width Scaling Shift Instructions

These instructions shift the input value right, and round off the
shifted out bits according to `vxrm`.  The scaling right shifts have
both zero-extending (`vssrl`) and sign-extending (`vssra`) forms. 
The low lg2(SEW) bits of the vector or scalar shift-amount value are used;
shift-amount immediates are zero-extended.

----
 # Scaling shift right logical
 vssrl.vv vd, vs2, vs1, vm   # vd[i] = roundoff_unsigned(vs2[i], vs1[i])
 vssrl.vx vd, vs2, rs1, vm   # vd[i] = roundoff_unsigned(vs2[i], x[rs1])
 vssrl.vi vd, vs2, uimm, vm  # vd[i] = roundoff_unsigned(vs2[i], uimm)

 # Scaling shift right arithmetic
 vssra.vv vd, vs2, vs1, vm   # vd[i] = roundoff_signed(vs2[i],vs1[i])
 vssra.vx vd, vs2, rs1, vm   # vd[i] = roundoff_signed(vs2[i], x[rs1])
 vssra.vi vd, vs2, uimm, vm  # vd[i] = roundoff_signed(vs2[i], uimm)
----

=== Vector Narrowing Fixed-Point Clip Instructions

The `vnclip` instructions are used to pack a fixed-point value into a
narrower destination.  The instructions support rounding, scaling, and
saturation into the final destination format.

The second argument (vector element, scalar value, immediate value)
gives the amount to right shift the source as in the narrowing shift
instructions, which provides the scaling.  The low lg2(2*SEW) bits of
the vector or scalar shift-amount value are used (e.g., the low 6 bits
for a SEW=64-bit to SEW=32-bit narrowing operation).  The immediate
forms zero-extend their shift-amount immediate operand.

----
# Narrowing unsigned clip
#                                SEW                            2*SEW   SEW
 vnclipu.wv vd, vs2, vs1, vm  # vd[i] = clip(roundoff_unsigned(vs2[i], vs1[i]))
 vnclipu.wx vd, vs2, rs1, vm  # vd[i] = clip(roundoff_unsigned(vs2[i], x[rs1]))
 vnclipu.wi vd, vs2, uimm, vm # vd[i] = clip(roundoff_unsigned(vs2[i], uimm))

# Narrowing signed clip
 vnclip.wv vd, vs2, vs1, vm   # vd[i] = clip(roundoff_signed(vs2[i], vs1[i]))
 vnclip.wx vd, vs2, rs1, vm   # vd[i] = clip(roundoff_signed(vs2[i], x[rs1]))
 vnclip.wi vd, vs2, uimm, vm  # vd[i] = clip(roundoff_signed(vs2[i], uimm))
----

For `vnclipu`/`vnclip`, the rounding mode is specified in the `vxrm`
CSR.  Rounding occurs around the least-significant bit of the
destination and before saturation.

For `vnclipu`, the shifted rounded source value is treated as an
unsigned integer and saturates if the result would overflow the
destination viewed as an unsigned integer.

NOTE: There is no single instruction that can saturate a signed value
into an unsigned destination.  A sequence of two vector instructions
that first removes negative numbers by performing a max against 0
using `vmax`, then clips the resulting unsigned value into the
destination using `vnclipu`, can be used if setting `vxsat` value is
not required.  A `vsetvli` is required inbetween these two
instructions to change SEW.

For `vnclip`, the shifted rounded source value is treated as a signed
integer and saturates if the result would overflow the destination viewed
as a signed integer.

If any destination element is saturated, the `vxsat` bit is set in the
`vxsat` register.

