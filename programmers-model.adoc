[[programmers-model]]
== Vector Extension Programmer's Model

The vector extension adds 32 vector registers, and seven unprivileged
CSRs (`vstart`, `vxsat`, `vxrm`, `vcsr`, `vtype`, `vl`, `vlenb`) to a
base scalar RISC-V ISA.

.New vector CSRs
[cols="2,2,2,10"]
[%autowidth]
|===
| Address | Privilege | Name   | Description

| 0x008 | URW | vstart | Vector start position
| 0x009 | URW | vxsat  | Fixed-Point Saturate Flag
| 0x00A | URW | vxrm   | Fixed-Point Rounding Mode
| 0x00F | URW | vcsr   | Vector control and status register
| 0xC20 | URO | vl     | Vector length
| 0xC21 | URO | vtype  | Vector data type register
| 0xC22 | URO | vlenb  | VLEN/8 (vector register length in bytes)
|===

=== Vector Registers

The vector extension adds 32 architectural vector registers,
`v0`-`v31` to the base scalar RISC-V ISA.

Each vector register has a fixed VLEN bits of state.

NOTE: Zfinx ("F in X") is a new ISA option under consideration where
floating-point instructions take their arguments from the integer
register file.  The 1.0 vector extension is also compatible with Zfinx.

=== Vector Context Status in `mstatus`

A vector context status field, `VS`, is added to `mstatus[10:9]` and shadowed
in `sstatus[10:9]`.  It is defined analogously to the floating-point context
status field, `FS`.

Attempts to execute any vector instruction, or to access the vector
CSRs, raise an illegal-instruction exception when the `VS` field is
set to Off.

When the `VS` field is set to Initial or Clean, executing any
instruction that changes vector state, including the vector CSRs, will
change `VS` to Dirty.
Implementations may also change the `VS` field from Initial or Clean to Dirty
at any time, even when there is no change in vector state.

[NOTE]
====
Accurate setting of the `VS` field is an optimization.  Software
will typically use VS to reduce context swap overhead.

Implementations may have a writable `misa.v` field.  Analogous to the
way in which the floating-point unit is handled, the `mstatus.vs`
field may exist even if `misa.v` is clear.

Allowing `mstatus.vs` to exist when `misa.v` is clear, enables
vector emulation and simplifies handling of `mstatus.vs` in systems
with writable `misa.v`.
====

=== Vector type register, `vtype`

The read-only XLEN-wide _vector_ _type_ CSR, `vtype` provides the
default type used to interpret the contents of the vector register
file, and can only be updated by `vset{i}vl{i}` instructions. The vector
type also determines the organization of elements in each vector
register, and how multiple vector registers are grouped.

NOTE: Allowing updates only via the `vset{i}vl{i}` instructions
simplifies maintenance of the `vtype` register state.

The `vtype` register has five fields,
`vill`, `vma`, `vta`, `vsew[2:0]`, and `vlmul[2:0]`.

include::vtype-format.adoc[]

[NOTE]
====
A small implementation supporting ELEN=32 requires only seven
bits of state in `vtype`: two bits for `ma` and `ta`, two bits for
`vsew[1:0]` and three bits for `vlmul[2:0]`.  The illegal value
represented by `vill` can be internally encoded using the illegal 64-bit
combination in `vsew[1:0]` without requiring an additional storage
bit to hold `vill`.

Further standard and custom vector extensions will extend these
fields to support a greater variety of data types.

It is anticipated that an extended 64-bit instruction encoding
would allow these fields to be specified statically in the instruction
encoding.
====

==== Vector selected element width `vsew[2:0]`

The value in `vsew` sets the dynamic _selected_ _element_ _width_
(SEW).  By default, a vector register is viewed as being divided into
VLEN/SEW elements.

.vsew[2:0] (selected element width) encoding
[cols="1,1,1,1,>13"]
[%autowidth]
|===
3+| vsew[2:0] | SEW |

| 0 | 0 | 0 |    8 |
| 0 | 0 | 1 |   16 |
| 0 | 1 | 0 |   32 |
| 0 | 1 | 1 |   64 |
| 1 | 0 | 0 |  128 | _Reserved_
| 1 | 0 | 1 |  256 | _Reserved_
| 1 | 1 | 0 |  512 | _Reserved_
| 1 | 1 | 1 | 1024 | _Reserved_
|===

NOTE: While it is anticipated the larger `vsew[2:0]` encodings
(`100`-`111`) will be used to encode larger SEW as shown in table, the
encodings are formally _reserved_ at this point.

.Example VLEN = 128 bits
[cols=">,>"]
[%autowidth]
|===
| SEW | Elements per vector register

| 64 |  2
| 32 |  4
| 16 |  8
|  8 | 16
|===

The supported element width may vary with LMUL, but profiles may
mandate the minimum SEW that must be supported with LMUL=1.

NOTE: Some implementations may support larger SEWs only when bits from
multiple vector registers are combined.  Software that relies on large
SEW should attempt to use the largest LMUL, and hence the fewest
vector register groups, to increase the number of implementations on
which the code will run. The `vill` bit in `vtype` should be checked
after setting `vtype` to see if the configuration is supported, and an
alternate code path should be provided if it is not. Alternatively, a
profile can mandate the minimum SEW at each LMUL setting.

==== Vector Register Grouping (`vlmul[2:0]`)

Multiple vector registers can be grouped together, so that a single
vector instruction can operate on multiple vector registers.  The term
_vector_ _register_ _group_ is used herein to refer to one or more
vector registers used as a single operand to a vector instruction.
Vector register groups allow double-width or larger elements to be
operated on with the same vector length as selected-width elements.
Vector register groups also provide greater execution efficiency for
longer application vectors.

The vector length multiplier, _LMUL_, when greater than 1, represents
the default number of vector registers that are combined to form a
vector register group.  Implementations must support LMUL integer values of 1,2,4,8.

LMUL can also be a fractional value, reducing the number of bits used
in a vector register.  LMUL can have fractional values 1/2, 1/4, 1/8.
Fractional LMUL is used to increase the number of usable architectural
registers when operating on mixed-width values, by not requiring that
larger-width vectors occupy multiple vector registers. Instead, wider
values can occupy a single vector register and narrower values can
occupy a fraction of a vector register.

Implementations must support fractional LMUL settings for LMUL {ge}
SEW~LMUL1MIN~/SEW~LMUL1MAX~, where SEW~LMUL1MIN~ is the narrowest
supported SEW value at LMUL=1 and SEW~LMUL1MAX~ is the widest
supported SEW value at LMUL=1.  An attempt to set an unsupported SEW
and LMUL configuration sets the `vill` bit in `vtype`.

For a given supported fractional LMUL setting, implementations must support
SEW settings between SEW~LMUL1MIN~ and LMUL * SEW~LMUL1MAX~, inclusive.

[NOTE]
====
Requiring LMUL {ge} SEW~LMUL1MIN~/SEW~LMUL1MAX~ allows software
operating on mixed-width elements to only use a single vector register
to hold the wider elements, with fractional
LMUL used to hold narrower elements.  When LMUL <
SEW~LMUL1MIN~/SEW~LMUL1MAX~, there is no guarantee an implementation
would have enough bits in the fractional vector register to store at
least one element, as VLEN=SEW~LMUL1MAX~ is a valid implementation
choice.

The constraint is written using SEW~LMUL1MAX~ and not ELEN
because some systems might only support larger SEW values for LMUL>1.
Note that in these cases, the constraint ensures that no more than a
single vector register is needed to hold the widest-supported element
that can be held in a single vector register, when code is also
performing operations on narrower widths.

The use of `vtype` encodings with LMUL < SEW~LMUL1MIN~/SEW~LMUL1MAX~ is
__reserved__, but implementations can set `vill` if they do not
support these configurations.

Requiring all implementations to set `vill` in this case would
prohibit future use of this case in an extension, so to allow for
a future definition of LMUL<SEW~LMUL1MIN~/SEW~LMUL1MAX~ behavior, we consider
the use of this case to be __reserved__.

It is recommended that assemblers provide a warning (not an
error) if a `vsetvli` instruction attempts to write an LMUL < SEW~LMUL1MIN~/SEW~LMUL1MAX~.
====

LMUL is set by the signed `vlmul` field in `vtype` (LMUL =
2^`vlmul[2:0]`^).

The derived value VLMAX = LMUL*VLEN/SEW represents the maximum number
of elements that can be operated on with a single vector instruction
given the current SEW and LMUL settings as shown in the table below.

[cols="1,1,1,2,2,5,5"]
[%autowidth]
|===
  3+| vlmul[2:0] | LMUL | #groups | VLMAX      | Registers grouped with register __n__

| 1 | 0 | 0 |   -  |     -   |     -      | reserved
| 1 | 0 | 1 |   1/8|     32  | VLEN/SEW/8 | `v` __n__ (single register in group)
| 1 | 1 | 0 |   1/4|     32  | VLEN/SEW/4 | `v` __n__ (single register in group)
| 1 | 1 | 1 |   1/2|     32  | VLEN/SEW/2 | `v` __n__ (single register in group)
| 0 | 0 | 0 |   1  |     32  |   VLEN/SEW | `v` __n__ (single register in group)
| 0 | 0 | 1 |   2  |     16  | 2*VLEN/SEW | `v` __n__, `v` __n__+1
| 0 | 1 | 0 |   4  |      8  | 4*VLEN/SEW | `v` __n__, ..., `v` __n__+3
| 0 | 1 | 1 |   8  |      4  | 8*VLEN/SEW | `v` __n__, ..., `v` __n__+7
|===

When LMUL=2, the vector register group contains vector register `v`
__n__ and vector register `v` __n__+1, providing twice the vector
length in bits.  Instructions specifying an LMUL=2 vector register group
with an odd-numbered vector register are reserved.

When LMUL=4, the vector register group contains four vector registers,
and instructions specifying an LMUL=4 vector register group using vector
register numbers that are not multiples of four are reserved.

When LMUL=8, the vector register group contains eight vector
registers, and instructions specifying an LMUL=8 vector register group
using register numbers that are not multiples of eight are reserved.

Mask registers are always contained in a single vector register,
regardless of LMUL.

[[sec-agnostic]]
==== Vector Tail Agnostic and Vector Mask Agnostic `vta` and `vma`

These two bits modify the behavior of destination tail elements and
destination inactive masked-off elements respectively during the
execution of vector instructions.  The tail and inactive sets contain
element positions that are not receiving new results during a vector
operation, as defined in Section <<sec-inactive-defs>>.

All systems must support all four options:

[cols="1,1,3,3"]
[%autowidth]
|===
| `vta` | `vma` | Tail Elements | Inactive Elements

|   0   |   0   | undisturbed   | undisturbed
|   0   |   1   | undisturbed   | agnostic
|   1   |   0   | agnostic      | undisturbed
|   1   |   1   | agnostic      | agnostic
|===

When a set is marked undisturbed, the corresponding set of destination
elements in a vector register group retain the value they previously
held.   Mask destination values are always treated as tail-agnostic,
regardless of the setting of `vta`.

When a set is marked agnostic, the corresponding set of destination
elements in any vector destination operand can either retain the value
they previously held, or are overwritten with 1s.  Within a single vector
instruction, each destination element can be either left undisturbed
or overwritten with 1s, in any combination, and the pattern of
undisturbed or overwritten with 1s is not required to be deterministic
when the instruction is executed with the same inputs.  In addition,
except for mask load instructions, any element in the tail of a mask
result can also be written with the value the mask-producing operation
would have calculated with `vl`=VLMAX.

NOTE: The agnostic policy was added to accommodate machines with vector
register renaming, and/or that have deeply temporal vector registers.
With an undisturbed policy, all elements would have to be read from
the old physical destination vector register to be copied into the new
physical destination vector register.  This causes an inefficiency
when these inactive or tail values are not required for subsequent
calculations.

NOTE: Mask tails are always treated as agnostic to reduce complexity
of managing mask data, which can be written at bit granularity.  There
appears to be little software need to support tail-undisturbed for
mask register values.  Allowing mask-generating instructions to write
back the result of the instruction avoids the need for logic to mask
out the tail, except mask loads cannot write memory values to
destination mask tails as this would imply accessing memory past
software intent.

[NOTE]
====
The value of all 1s instead of all 0s was chosen for the
overwrite value to discourage software developers from depending on
the value written.

A simple in-order implementation can ignore the settings and
simply execute all vector instructions using the undisturbed
policy. The `vta` and `vma` state bits must still be provided in
`vtype` for compatibility and to support thread migration.

An out-of-order implementation can choose to implement
tail-agnostic + mask-agnostic using tail-agnostic + mask-undisturbed
to reduce implementation complexity.

The definition of agnostic result policy is left loose to
accommodate migrating application threads between harts on a small
in-order core (which probably leaves agnostic regions undisturbed) and
harts on a larger out-of-order core with register renaming (which
probably overwrites agnostic elements with 1s).  As it might be
necessary to restart in the middle, we allow arbitrary mixing of
agnostic policies within a single vector instruction.  This allowed
mixing of policies also enables implementations that might change
policies for different granules of a vector register, for example,
using undisturbed within a granule that is actively operated on but
renaming to all 1s for granules in the tail.
====

The assembly syntax adds two flags to the `vsetvli` instruction:

----
 ta   # Tail agnostic
 tu   # Tail undisturbed
 ma   # Mask agnostic
 mu   # Mask undisturbed

 vsetvli t0, a0, e32, m4, ta, ma   # Tail agnostic, mask agnostic
 vsetvli t0, a0, e32, m4, tu, ma   # Tail undisturbed, mask agnostic
 vsetvli t0, a0, e32, m4, ta, mu   # Tail agnostic, mask undisturbed
 vsetvli t0, a0, e32, m4, tu, mu   # Tail undisturbed, mask undisturbed
----

NOTE: To maintain backward compatibility in the short term and reduce
software churn in the move to 0.9, when these flags are not specified
on a `vsetvli`, they should default to
mask-undisturbed/tail-undisturbed.  The use of `vsetvli` without these
flags should be deprecated, however, such that the specifying a flag
setting becomes mandatory.  If anything, the default should be
tail-agnostic/mask-agnostic, so software has to specify when it cares
about the non-participating elements, but given the historical meaning
of the instruction prior to introduction of these flags, it is safest
to always require them in future assembly code.

==== Vector Type Illegal `vill`

The `vill` bit is used to encode that a previous `vset{i}vl{i}`
instruction attempted to write an unsupported value to `vtype`.

NOTE: The `vill` bit is held in bit XLEN-1 of the CSR to support
checking for illegal values with a branch on the sign bit.

If the `vill` bit is set, then any attempt to execute a vector instruction
that depends upon `vtype` will raise an illegal-instruction exception.

NOTE: `vset{i}vl{i}` and whole-register loads, stores, and moves do not depend
upon `vtype`.

When the `vill` bit is set, the other XLEN-1 bits in `vtype` shall be
zero.

=== Vector Length Register `vl`

The _XLEN_-bit-wide read-only `vl` CSR can only be updated by the
`vset{i}vl{i}` instructions, and the _fault-only-first_ vector load
instruction variants.

The `vl` register holds an unsigned integer specifying the number of
elements to be updated with results from a vector instruction, as
further detailed in Section <<sec-inactive-defs>>.

NOTE: The number of bits implemented in `vl` depends on the
implementation's maximum vector length of the smallest supported
type. The smallest vector implementation with VLEN=32 and supporting
SEW=8 would need at least six bits in `vl` to hold the values 0-32
(VLEN=32, with LMUL=8 and SEW=8, yields VLMAX=32).

=== Vector Byte Length `vlenb`

The _XLEN_-bit-wide read-only CSR `vlenb` holds the value VLEN/8,
i.e., the vector register length in bytes.

[NOTE]
====
The value in `vlenb` is a design-time constant in any
implementation.

Without this CSR, several instructions are needed to calculate
VLEN in bytes, and the code has to disturb current `vl` and `vtype`
settings which require them to be saved and restored.
====

=== Vector Start Index CSR `vstart`

The `vstart` read-write CSR specifies the index of the first element
to be executed by a vector instruction, as described in Section
<<sec-inactive-defs>>.

Normally, `vstart` is only written by hardware on a trap on a vector
instruction, with the `vstart` value representing the element on which
the trap was taken (either a synchronous exception or an asynchronous
interrupt), and at which execution should resume after a resumable
trap is handled.

All vector instructions are defined to begin execution with the
element number given in the `vstart` CSR, leaving earlier elements in
the destination vector undisturbed, and to reset the `vstart` CSR to
zero at the end of execution.

NOTE: All vector instructions, including `vset{i}vl{i}`, reset the `vstart`
CSR to zero.

`vstart` is not modified by vector instructions that raise illegal-instruction
exceptions.

The `vstart` CSR is defined to have only enough writable bits to hold
the largest element index (one less than the maximum VLMAX).

NOTE: The maximum vector length is obtained with the largest LMUL
setting (8) and the smallest SEW setting (8), so VLMAX_max = 8*VLEN/8
= VLEN.  For example, for VLEN=256, `vstart` would have 8 bits to
represent indices from 0 through 255.

The use of `vstart` values greater than the largest element index for
the current SEW setting is reserved.

NOTE: It is recommended that implementations trap if `vstart` is out
of bounds.  It is not required to trap, as a possible future use of
upper `vstart` bits is to store imprecise trap information.

The `vstart` CSR is writable by unprivileged code, but non-zero
`vstart` values may cause vector instructions to run substantially
slower on some implementations, so `vstart` should not be used by
application programmers.  A few vector instructions cannot be
executed with a non-zero `vstart` value and will raise an illegal
instruction exception as defined below.

NOTE: Making `vstart` visible to unprivileged code supports user-level
threading libraries.

Implementations are permitted to raise illegal instruction exceptions when
attempting to execute a vector instruction with a value of `vstart` that the
implementation can never produce when executing that same instruction with
the same `vtype` setting.

NOTE: For example, some implementations will never take interrupts during
execution of a vector arithmetic instruction, instead waiting until the
instruction completes to take the interrupt.  Such implementations are
permitted to raise an illegal instruction exception when attempting to execute
a vector arithmetic instruction when `vstart` is nonzero.

NOTE: When migrating a software thread between two harts with
different microarchitectures, the `vstart` value might not be
supported by the new hart microarchitecture.  The runtime on the
receiving hart might then have to emulate instruction execution to a
supported vstart element position.  Alternatively, migration events
can be constrained to only occur at mutually supported `vstart`
locations.

=== Vector Fixed-Point Rounding Mode Register `vxrm`

The vector fixed-point rounding-mode register holds a two-bit
read-write rounding-mode field.  The vector fixed-point rounding-mode
is given a separate CSR address to allow independent access, but is
also reflected as a field in `vcsr`.

The fixed-point rounding algorithm is specified as follows.
Suppose the pre-rounding result is `v`, and `d` bits of that result are to be
rounded off.
Then the rounded result is `(v >> d) + r`, where `r` depends on the rounding
mode as specified in the following table.

.vxrm encoding
[cols="1,1,4,10,5"]
[%autowidth]
|===
2+| `vxrm[1:0]` | Abbreviation | Rounding Mode | Rounding increment, `r`

| 0 | 0 | rnu | round-to-nearest-up (add +0.5 LSB)          | `v[d-1]`
| 0 | 1 | rne | round-to-nearest-even                       | `v[d-1] & (v[d-2:0]{ne}0 \| v[d])`
| 1 | 0 | rdn | round-down (truncate)                       | `0`
| 1 | 1 | rod | round-to-odd (OR bits into LSB, aka "jam")  | `!v[d] & v[d-1:0]{ne}0`
|===

The rounding functions:
----
roundoff_unsigned(v, d) = (unsigned(v) >> d) + r
roundoff_signed(v, d) = (signed(v) >> d) + r
----
are used to represent this operation in the instruction descriptions below.

`vxrm[XLEN-1:2]` should be written as zeros.

NOTE: A new rounding mode can be set while saving the original
rounding mode using a single `csrwi` instruction.

=== Vector Fixed-Point Saturation Flag `vxsat`

The `vxsat` CSR holds a single read-write bit that indicates if a
fixed-point instruction has had to saturate an output value to fit
into a destination format.

The `vxsat` bit is mirrored in `vcsr`.

=== Vector Control and Status Register `vcsr`

The `vxrm` and `vxsat` separate CSRs can also be accessed via fields
in the vector control and status CSR, `vcsr`.

.vcsr layout
[cols=">2,4,10"]
[%autowidth]
|===
| Bits | Name   | Description


|  2:1 | vxrm[1:0] | Fixed-point rounding mode
|    0 | vxsat     | Fixed-point accrued saturation flag
|===

=== State of Vector Extension at Reset

The vector extension must have a consistent state at reset.  In
particular, `vtype` and `vl` must have values that can be read and
then restored with a single `vsetvl` instruction.

NOTE: It is recommended that at reset, `vtype.vill` is set, the
remaining bits in `vtype` are zero, and `vl` is set to zero.

The `vstart`, `vxrm`, `vxsat` CSRs can have arbitrary values at reset.

NOTE: Most uses of the vector unit will require an initial `vset{i}vl{i}`,
which will reset `vstart`.  The `vxrm` and `vxsat` fields should be
reset explicitly in software before use.

The vector registers can have arbitrary values at reset.
